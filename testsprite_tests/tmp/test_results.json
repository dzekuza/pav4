[
  {
    "projectId": "2c4a704e-038b-40cd-a8c9-af06845f8369",
    "testId": "d2685178-5063-48b2-80dd-a5f89bb41bb5",
    "userId": "341874e8-2011-70cc-0ea8-47f80d67dcd0",
    "title": "TC001-verify_user_registration_functionality",
    "description": "Test the user registration endpoint to ensure new users can register successfully with valid email and password, and receive a JWT token and user details in response.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nREGISTER_ENDPOINT = f\"{BASE_URL}/api/auth/register\"\nDELETE_USER_ENDPOINT = f\"{BASE_URL}/api/admin/users\"  # No delete user endpoint specified in PRD, so no direct delete\n\ndef verify_user_registration_functionality():\n    # Generate unique email to avoid conflicts\n    unique_email = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\n    password = \"StrongPassw0rd!\"\n\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    payload = {\n        \"email\": unique_email,\n        \"password\": password\n    }\n\n    try:\n        response = requests.post(REGISTER_ENDPOINT, json=payload, headers=headers, timeout=30)\n    except requests.RequestException as e:\n        assert False, f\"Request to register user failed: {e}\"\n\n    assert response.status_code == 201, f\"Expected status code 201, got {response.status_code}\"\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Validate response structure and content\n    assert isinstance(data, dict), \"Response JSON is not an object\"\n    assert data.get(\"success\") is True, \"Registration success flag is not True\"\n    token = data.get(\"token\") or data.get(\"accessToken\")\n    assert token and isinstance(token, str) and len(token) > 0, \"JWT token missing or invalid\"\n    user = data.get(\"user\")\n    assert isinstance(user, dict), \"User object missing or invalid\"\n    assert isinstance(user.get(\"id\"), int), \"User id missing or not integer\"\n    assert user.get(\"email\") == unique_email, \"User email in response does not match registration email\"\n    assert isinstance(user.get(\"isAdmin\"), bool), \"User isAdmin flag missing or not boolean\"\n\n    # No delete user endpoint provided in PRD, so cannot clean up created user\n\nverify_user_registration_functionality()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-07-20T17:41:58.970Z",
    "modified": "2025-07-20T17:42:30.840Z"
  },
  {
    "projectId": "2c4a704e-038b-40cd-a8c9-af06845f8369",
    "testId": "fb17ed4c-2047-40de-9d9a-5359c9a42869",
    "userId": "341874e8-2011-70cc-0ea8-47f80d67dcd0",
    "title": "TC002-verify_user_login_functionality",
    "description": "Test the user login endpoint to verify that registered users can log in with correct credentials and receive a valid JWT token and user information.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef verify_user_login_functionality():\n    register_url = f\"{BASE_URL}/api/auth/register\"\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    logout_url = f\"{BASE_URL}/api/auth/logout\"\n\n    # Generate unique email for registration\n    unique_email = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\n    password = \"TestPass123!\"\n\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # Register a new user to ensure user exists for login test\n    register_payload = {\n        \"email\": unique_email,\n        \"password\": password\n    }\n\n    user_id = None\n    token = None\n\n    try:\n        reg_resp = requests.post(register_url, json=register_payload, headers=headers, timeout=TIMEOUT)\n        assert reg_resp.status_code == 201, f\"Registration failed with status {reg_resp.status_code}\"\n        reg_json = reg_resp.json()\n        assert reg_json.get(\"success\") is True, \"Registration response success flag is not True\"\n        assert \"token\" in reg_json and isinstance(reg_json[\"token\"], str) and reg_json[\"token\"], \"No token in registration response\"\n        assert \"user\" in reg_json and isinstance(reg_json[\"user\"], dict), \"No user object in registration response\"\n        user = reg_json[\"user\"]\n        assert \"id\" in user and isinstance(user[\"id\"], int), \"User id missing or invalid in registration response\"\n        assert user.get(\"email\") == unique_email, \"User email mismatch in registration response\"\n        user_id = user[\"id\"]\n\n        # Now test login with the registered user credentials\n        login_payload = {\n            \"email\": unique_email,\n            \"password\": password\n        }\n        login_resp = requests.post(login_url, json=login_payload, headers=headers, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n        login_json = login_resp.json()\n        assert login_json.get(\"success\") is True, \"Login response success flag is not True\"\n        assert \"token\" in login_json and isinstance(login_json[\"token\"], str) and login_json[\"token\"], \"No token in login response\"\n        assert \"accessToken\" in login_json and isinstance(login_json[\"accessToken\"], str) and login_json[\"accessToken\"], \"No accessToken in login response\"\n        assert \"user\" in login_json and isinstance(login_json[\"user\"], dict), \"No user object in login response\"\n        login_user = login_json[\"user\"]\n        assert \"id\" in login_user and login_user[\"id\"] == user_id, \"User id mismatch in login response\"\n        assert login_user.get(\"email\") == unique_email, \"User email mismatch in login response\"\n        assert \"isAdmin\" in login_user and isinstance(login_user[\"isAdmin\"], bool), \"isAdmin missing or invalid in login response\"\n\n        token = login_json[\"token\"]\n\n    finally:\n        # Cleanup: logout the user if token is available\n        if token:\n            logout_headers = {\"Authorization\": f\"Bearer {token}\"}\n            try:\n                logout_resp = requests.post(logout_url, headers=logout_headers, timeout=TIMEOUT)\n                assert logout_resp.status_code == 200, f\"Logout failed with status {logout_resp.status_code}\"\n                logout_json = logout_resp.json()\n                assert logout_json.get(\"success\") is True, \"Logout response success flag is not True\"\n            except Exception:\n                pass\n\nverify_user_login_functionality()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-07-20T17:41:58.977Z",
    "modified": "2025-07-20T17:42:40.192Z"
  },
  {
    "projectId": "2c4a704e-038b-40cd-a8c9-af06845f8369",
    "testId": "191d797f-09af-495e-9ca0-1a0aff6575f2",
    "userId": "341874e8-2011-70cc-0ea8-47f80d67dcd0",
    "title": "TC003-verify_user_logout_functionality",
    "description": "Test the user logout endpoint to confirm that users can log out successfully and receive a confirmation response.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef verify_user_logout_functionality():\n    register_url = f\"{BASE_URL}/api/auth/register\"\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    logout_url = f\"{BASE_URL}/api/auth/logout\"\n\n    # Generate unique email for registration\n    unique_email = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\n    password = \"TestPassword123!\"\n\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # Register a new user\n    register_payload = {\n        \"email\": unique_email,\n        \"password\": password\n    }\n    try:\n        reg_resp = requests.post(register_url, json=register_payload, headers=headers, timeout=TIMEOUT)\n        assert reg_resp.status_code == 201, f\"Registration failed with status {reg_resp.status_code}\"\n        reg_data = reg_resp.json()\n        assert reg_data.get(\"success\") is True, \"Registration success flag not True\"\n        assert \"accessToken\" in reg_data, \"accessToken missing in registration response\"\n    except Exception as e:\n        raise AssertionError(f\"User registration failed: {e}\")\n\n    # Login with the registered user\n    login_payload = {\n        \"email\": unique_email,\n        \"password\": password\n    }\n    try:\n        login_resp = requests.post(login_url, json=login_payload, headers=headers, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n        login_data = login_resp.json()\n        assert login_data.get(\"success\") is True, \"Login success flag not True\"\n        access_token = login_data.get(\"accessToken\")\n        assert access_token, \"accessToken missing in login response\"\n    except Exception as e:\n        raise AssertionError(f\"User login failed: {e}\")\n\n    # Logout the user using the access token\n    logout_headers = {\n        \"Authorization\": f\"Bearer {access_token}\"\n    }\n    try:\n        logout_resp = requests.post(logout_url, headers=logout_headers, timeout=TIMEOUT)\n        assert logout_resp.status_code == 200, f\"Logout failed with status {logout_resp.status_code}\"\n        logout_data = logout_resp.json()\n        assert logout_data.get(\"success\") is True, \"Logout success flag not True\"\n    except Exception as e:\n        raise AssertionError(f\"User logout failed: {e}\")\n\nverify_user_logout_functionality()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-07-20T17:41:58.983Z",
    "modified": "2025-07-20T17:42:33.640Z"
  },
  {
    "projectId": "2c4a704e-038b-40cd-a8c9-af06845f8369",
    "testId": "71a60523-d03a-4cce-b4f3-ccdda317c417",
    "userId": "341874e8-2011-70cc-0ea8-47f80d67dcd0",
    "title": "TC004-verify_get_current_user_info",
    "description": "Test the endpoint to retrieve current authenticated user information, ensuring it returns correct user details including id, email, and admin status.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_verify_get_current_user_info():\n    register_url = f\"{BASE_URL}/api/auth/register\"\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    me_url = f\"{BASE_URL}/api/auth/me\"\n    logout_url = f\"{BASE_URL}/api/auth/logout\"\n\n    # Generate unique email for registration\n    unique_email = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\n    password = \"TestPassword123!\"\n\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # Register user\n    register_payload = {\n        \"email\": unique_email,\n        \"password\": password\n    }\n    try:\n        reg_resp = requests.post(register_url, json=register_payload, headers=headers, timeout=TIMEOUT)\n        assert reg_resp.status_code == 201, f\"Registration failed: {reg_resp.text}\"\n        reg_data = reg_resp.json()\n        assert reg_data.get(\"success\") is True\n        assert \"accessToken\" in reg_data\n        assert \"user\" in reg_data\n        user_registered = reg_data[\"user\"]\n        assert isinstance(user_registered.get(\"id\"), int)\n        assert user_registered.get(\"email\") == unique_email\n        assert isinstance(user_registered.get(\"isAdmin\"), bool)\n\n        # Login user\n        login_payload = {\n            \"email\": unique_email,\n            \"password\": password\n        }\n        login_resp = requests.post(login_url, json=login_payload, headers=headers, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        login_data = login_resp.json()\n        assert login_data.get(\"success\") is True\n        token = login_data.get(\"accessToken\")\n        assert token is not None and isinstance(token, str)\n        user_logged_in = login_data.get(\"user\")\n        assert user_logged_in.get(\"email\") == unique_email\n        assert isinstance(user_logged_in.get(\"id\"), int)\n        assert isinstance(user_logged_in.get(\"isAdmin\"), bool)\n\n        auth_headers = {\n            \"Authorization\": f\"Bearer {token}\"\n        }\n\n        # Get current user info\n        me_resp = requests.get(me_url, headers=auth_headers, timeout=TIMEOUT)\n        assert me_resp.status_code == 200, f\"Get current user info failed: {me_resp.text}\"\n        me_data = me_resp.json()\n        assert \"user\" in me_data\n        user_info = me_data[\"user\"]\n        assert isinstance(user_info.get(\"id\"), int)\n        assert user_info.get(\"email\") == unique_email\n        assert isinstance(user_info.get(\"isAdmin\"), bool)\n\n    finally:\n        # Logout user if token exists\n        if 'token' in locals():\n            try:\n                requests.post(logout_url, headers={\"Authorization\": f\"Bearer {token}\"}, timeout=TIMEOUT)\n            except Exception:\n                pass\n\ntest_verify_get_current_user_info()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-07-20T17:41:58.989Z",
    "modified": "2025-07-20T17:42:43.769Z"
  },
  {
    "projectId": "2c4a704e-038b-40cd-a8c9-af06845f8369",
    "testId": "c62b1a8d-2562-455a-bb3d-4707164aeefa",
    "userId": "341874e8-2011-70cc-0ea8-47f80d67dcd0",
    "title": "TC005-verify_add_search_to_history",
    "description": "Test the add search to history endpoint to ensure authenticated users can add search entries with url, title, and requestId, and receive a success response.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_verify_add_search_to_history():\n    # Register a new user\n    register_url = f\"{BASE_URL}/api/auth/register\"\n    email = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\n    password = \"TestPassword123!\"\n    register_payload = {\n        \"email\": email,\n        \"password\": password\n    }\n    try:\n        register_resp = requests.post(register_url, json=register_payload, timeout=TIMEOUT)\n        assert register_resp.status_code == 201, f\"Registration failed: {register_resp.text}\"\n        register_data = register_resp.json()\n        assert register_data.get(\"success\") is True\n        access_token = register_data.get(\"accessToken\") or register_data.get(\"token\")\n        assert access_token, \"No access token received on registration\"\n\n        headers = {\n            \"Authorization\": f\"Bearer {access_token}\",\n            \"Content-Type\": \"application/json\"\n        }\n\n        # Prepare search history entry\n        search_history_url = f\"{BASE_URL}/api/search-history\"\n        search_entry = {\n            \"url\": \"https://example.com/product/12345\",\n            \"title\": \"Example Product Title\",\n            \"requestId\": str(uuid.uuid4())\n        }\n\n        # Add search to history\n        add_resp = requests.post(search_history_url, json=search_entry, headers=headers, timeout=TIMEOUT)\n        assert add_resp.status_code == 201, f\"Failed to add search to history: {add_resp.text}\"\n\n        # Optionally, verify the search was added by retrieving history\n        get_resp = requests.get(search_history_url, headers=headers, timeout=TIMEOUT)\n        assert get_resp.status_code == 200, f\"Failed to get search history: {get_resp.text}\"\n        history_data = get_resp.json()\n        history = history_data.get(\"history\", [])\n        # Check that the added entry is in the history (match by requestId)\n        found = any(item.get(\"requestId\") == search_entry[\"requestId\"] and\n                    item.get(\"url\") == search_entry[\"url\"] and\n                    item.get(\"title\") == search_entry[\"title\"] for item in history)\n        assert found, \"Added search entry not found in history\"\n\n    finally:\n        # Logout the user to clean up session if needed\n        if 'access_token' in locals():\n            logout_url = f\"{BASE_URL}/api/auth/logout\"\n            try:\n                requests.post(logout_url, headers={\"Authorization\": f\"Bearer {access_token}\"}, timeout=TIMEOUT)\n            except Exception:\n                pass\n\ntest_verify_add_search_to_history()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-07-20T17:41:58.995Z",
    "modified": "2025-07-20T17:42:37.327Z"
  },
  {
    "projectId": "2c4a704e-038b-40cd-a8c9-af06845f8369",
    "testId": "7a6cf63c-9f92-44b4-b879-6e15ec4eff7e",
    "userId": "341874e8-2011-70cc-0ea8-47f80d67dcd0",
    "title": "TC006-verify_get_user_search_history",
    "description": "Test the get user search history endpoint to verify that authenticated users can retrieve their search history with correct details and timestamps.",
    "code": "import requests\nimport uuid\nimport time\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef verify_get_user_search_history():\n    # Register a new user\n    register_url = f\"{BASE_URL}/api/auth/register\"\n    email = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\n    password = \"TestPass123!\"\n    register_payload = {\"email\": email, \"password\": password}\n    try:\n        register_resp = requests.post(register_url, json=register_payload, timeout=TIMEOUT)\n        assert register_resp.status_code == 201, f\"Registration failed: {register_resp.text}\"\n        register_data = register_resp.json()\n        assert register_data.get(\"success\") is True\n        token = register_data.get(\"token\") or register_data.get(\"accessToken\")\n        assert token, \"No token received on registration\"\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n\n        # Scrape a product to get a requestId and product title\n        scrape_url = f\"{BASE_URL}/api/scrape\"\n        test_product_url = \"https://example.com/product/test-product\"\n        scrape_payload = {\"url\": test_product_url}\n        scrape_resp = requests.post(scrape_url, json=scrape_payload, headers=headers, timeout=TIMEOUT)\n        assert scrape_resp.status_code == 200, f\"Scrape failed: {scrape_resp.text}\"\n        scrape_data = scrape_resp.json()\n        product = scrape_data.get(\"product\")\n        request_id = scrape_data.get(\"requestId\")\n        assert product and isinstance(product, dict), \"Product data missing or invalid\"\n        assert request_id and isinstance(request_id, str), \"requestId missing or invalid\"\n        product_title = product.get(\"title\")\n        assert product_title and isinstance(product_title, str), \"Product title missing or invalid\"\n\n        # Add search to history\n        add_history_url = f\"{BASE_URL}/api/search-history\"\n        add_history_payload = {\n            \"url\": test_product_url,\n            \"title\": product_title,\n            \"requestId\": request_id\n        }\n        add_resp = requests.post(add_history_url, json=add_history_payload, headers=headers, timeout=TIMEOUT)\n        assert add_resp.status_code == 201, f\"Add search to history failed: {add_resp.text}\"\n\n        # Wait briefly to ensure timestamp difference if needed\n        time.sleep(1)\n\n        # Get user search history\n        get_history_url = f\"{BASE_URL}/api/search-history\"\n        get_resp = requests.get(get_history_url, headers=headers, timeout=TIMEOUT)\n        assert get_resp.status_code == 200, f\"Get search history failed: {get_resp.text}\"\n        history_data = get_resp.json()\n        history = history_data.get(\"history\")\n        assert isinstance(history, list), \"History is not a list\"\n\n        # Find the added search entry in history\n        matched_entries = [\n            entry for entry in history\n            if entry.get(\"url\") == test_product_url and\n               entry.get(\"title\") == product_title and\n               entry.get(\"requestId\") == request_id\n        ]\n        assert matched_entries, \"Added search entry not found in history\"\n\n        # Validate timestamp format (ISO 8601 string)\n        for entry in matched_entries:\n            timestamp = entry.get(\"timestamp\")\n            assert isinstance(timestamp, str) and len(timestamp) > 0, \"Timestamp missing or invalid\"\n\n    finally:\n        # Logout user to clean session (optional)\n        try:\n            logout_url = f\"{BASE_URL}/api/auth/logout\"\n            requests.post(logout_url, headers={\"Authorization\": f\"Bearer {token}\"}, timeout=TIMEOUT)\n        except Exception:\n            pass\n\nverify_get_user_search_history()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/urllib3/connectionpool.py\", line 534, in _make_request\n    response = conn.getresponse()\n               ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connection.py\", line 565, in getresponse\n    httplib_response = super().getresponse()\n                       ^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 1430, in getresponse\n    response.begin()\n  File \"/var/lang/lib/python3.12/http/client.py\", line 331, in begin\n    version, status, reason = self._read_status()\n                              ^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/http/client.py\", line 292, in _read_status\n    line = str(self.fp.readline(_MAXLINE + 1), \"iso-8859-1\")\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/lang/lib/python3.12/socket.py\", line 720, in readinto\n    return self._sock.recv_into(b)\n           ^^^^^^^^^^^^^^^^^^^^^^^\nTimeoutError: timed out\n\nThe above exception was the direct cause of the following exception:\n\nTraceback (most recent call last):\n  File \"/var/task/requests/adapters.py\", line 667, in send\n    resp = conn.urlopen(\n           ^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 841, in urlopen\n    retries = retries.increment(\n              ^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/retry.py\", line 474, in increment\n    raise reraise(type(error), error, _stacktrace)\n          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/util/util.py\", line 39, in reraise\n    raise value\n  File \"/var/task/urllib3/connectionpool.py\", line 787, in urlopen\n    response = self._make_request(\n               ^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/urllib3/connectionpool.py\", line 536, in _make_request\n    self._raise_timeout(err=e, url=url, timeout_value=read_timeout)\n  File \"/var/task/urllib3/connectionpool.py\", line 367, in _raise_timeout\n    raise ReadTimeoutError(\nurllib3.exceptions.ReadTimeoutError: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 80, in <module>\n  File \"<string>\", line 27, in verify_get_user_search_history\n  File \"/var/task/requests/api.py\", line 115, in post\n    return request(\"post\", url, data=data, json=json, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/api.py\", line 59, in request\n    return session.request(method=method, url=url, **kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 589, in request\n    resp = self.send(prep, **send_kwargs)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/sessions.py\", line 703, in send\n    r = adapter.send(request, **kwargs)\n        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/var/task/requests/adapters.py\", line 713, in send\n    raise ReadTimeout(e, request=request)\nrequests.exceptions.ReadTimeout: HTTPConnectionPool(host='tun.testsprite.com', port=8080): Read timed out. (read timeout=30)\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-07-20T17:41:59.001Z",
    "modified": "2025-07-20T17:43:21.627Z"
  },
  {
    "projectId": "2c4a704e-038b-40cd-a8c9-af06845f8369",
    "testId": "484d6e24-497d-4095-a4ff-386af46df028",
    "userId": "341874e8-2011-70cc-0ea8-47f80d67dcd0",
    "title": "TC007-verify_product_scraping_functionality",
    "description": "Test the product scraping endpoint to ensure it scrapes product data correctly from a given URL, including product details and price comparisons, and returns a valid requestId.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef verify_product_scraping_functionality():\n    scrape_url = \"https://example.com/product/sample-product\"\n    user_location = {\"country\": \"US\"}\n\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    payload = {\n        \"url\": scrape_url,\n        \"userLocation\": user_location\n    }\n\n    try:\n        response = requests.post(f\"{BASE_URL}/api/scrape\", json=payload, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to /api/scrape failed: {e}\"\n\n    data = response.json()\n\n    # Validate presence of requestId\n    assert \"requestId\" in data and isinstance(data[\"requestId\"], str) and data[\"requestId\"].strip() != \"\", \"Missing or invalid requestId\"\n\n    # Validate product object\n    assert \"product\" in data and isinstance(data[\"product\"], dict), \"Missing or invalid product data\"\n    product = data[\"product\"]\n    assert isinstance(product.get(\"title\"), str) and product[\"title\"].strip() != \"\", \"Product title missing or empty\"\n    assert isinstance(product.get(\"price\"), (int, float)), \"Product price missing or not a number\"\n    assert isinstance(product.get(\"currency\"), str) and product[\"currency\"].strip() != \"\", \"Product currency missing or empty\"\n    assert isinstance(product.get(\"url\"), str) and product[\"url\"].strip() != \"\", \"Product url missing or empty\"\n    assert isinstance(product.get(\"image\"), str), \"Product image missing or not a string\"\n    assert isinstance(product.get(\"store\"), str), \"Product store missing or not a string\"\n\n    # Validate comparisons array\n    assert \"comparisons\" in data and isinstance(data[\"comparisons\"], list), \"Missing or invalid comparisons data\"\n    for comp in data[\"comparisons\"]:\n        assert isinstance(comp, dict), \"Comparison item is not an object\"\n        assert isinstance(comp.get(\"title\"), str) and comp[\"title\"].strip() != \"\", \"Comparison title missing or empty\"\n        assert isinstance(comp.get(\"store\"), str), \"Comparison store missing or not a string\"\n        assert isinstance(comp.get(\"price\"), (int, float)), \"Comparison price missing or not a number\"\n        assert isinstance(comp.get(\"currency\"), str) and comp[\"currency\"].strip() != \"\", \"Comparison currency missing or empty\"\n        assert isinstance(comp.get(\"url\"), str) and comp[\"url\"].strip() != \"\", \"Comparison url missing or empty\"\n        assert isinstance(comp.get(\"image\"), str), \"Comparison image missing or not a string\"\n        assert isinstance(comp.get(\"condition\"), str), \"Comparison condition missing or not a string\"\n        assert isinstance(comp.get(\"assessment\"), dict), \"Comparison assessment missing or not an object\"\n\nverify_product_scraping_functionality()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 54, in <module>\n  File \"<string>\", line 29, in verify_product_scraping_functionality\nAssertionError: Missing or invalid requestId\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-07-20T17:41:59.007Z",
    "modified": "2025-07-20T17:43:24.435Z"
  },
  {
    "projectId": "2c4a704e-038b-40cd-a8c9-af06845f8369",
    "testId": "ab0ea41f-48cb-4e53-ae71-1b89388ac7f5",
    "userId": "341874e8-2011-70cc-0ea8-47f80d67dcd0",
    "title": "TC008-verify_n8n_webhook_scraping",
    "description": "Test the N8N webhook scraping endpoint to confirm it processes scraping requests correctly, returning main product details and suggestions with pricing and links.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_verify_n8n_webhook_scraping():\n    url_to_scrape = \"https://example.com/product/sample-product\"\n    request_id = str(uuid.uuid4())\n    payload = {\n        \"url\": url_to_scrape,\n        \"requestId\": request_id,\n        \"userLocation\": {\n            \"country\": \"US\"\n        }\n    }\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n\n    try:\n        response = requests.post(\n            f\"{BASE_URL}/api/n8n-scrape\",\n            json=payload,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 200, f\"Expected status 200 but got {response.status_code}\"\n        data = response.json()\n\n        # Validate mainProduct presence and fields\n        assert \"mainProduct\" in data, \"Response missing 'mainProduct'\"\n        main_product = data[\"mainProduct\"]\n        assert isinstance(main_product, dict), \"'mainProduct' should be an object\"\n        for field in [\"title\", \"price\", \"image\", \"url\"]:\n            assert field in main_product, f\"'mainProduct' missing field '{field}'\"\n            assert isinstance(main_product[field], str), f\"'mainProduct.{field}' should be a string\"\n            assert main_product[field].strip() != \"\", f\"'mainProduct.{field}' should not be empty\"\n\n        # Validate suggestions presence and structure\n        assert \"suggestions\" in data, \"Response missing 'suggestions'\"\n        suggestions = data[\"suggestions\"]\n        assert isinstance(suggestions, list), \"'suggestions' should be a list\"\n        for suggestion in suggestions:\n            assert isinstance(suggestion, dict), \"Each suggestion should be an object\"\n            for field in [\"title\", \"standardPrice\", \"discountPrice\", \"site\", \"link\", \"image\"]:\n                assert field in suggestion, f\"Suggestion missing field '{field}'\"\n                assert isinstance(suggestion[field], str), f\"Suggestion field '{field}' should be a string\"\n                # Allow empty strings for discountPrice if no discount, but others should not be empty\n                if field != \"discountPrice\":\n                    assert suggestion[field].strip() != \"\", f\"Suggestion field '{field}' should not be empty\"\n\n    except requests.RequestException as e:\n        assert False, f\"Request to /api/n8n-scrape failed: {e}\"\n\ntest_verify_n8n_webhook_scraping()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-07-20T17:41:59.013Z",
    "modified": "2025-07-20T17:43:18.650Z"
  },
  {
    "projectId": "2c4a704e-038b-40cd-a8c9-af06845f8369",
    "testId": "aad4ff12-1267-4592-b231-198e31c29db4",
    "userId": "341874e8-2011-70cc-0ea8-47f80d67dcd0",
    "title": "TC009-verify_get_user_location_and_local_dealers",
    "description": "Test the location endpoint to ensure it returns accurate user location data and a list of local dealers with relevant details such as name, url, country, and currency.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_verify_get_user_location_and_local_dealers():\n    url = f\"{BASE_URL}/api/location\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to /api/location failed: {e}\"\n\n    data = response.json()\n\n    # Validate top-level keys\n    assert \"location\" in data, \"Response missing 'location' key\"\n    assert \"localDealers\" in data, \"Response missing 'localDealers' key\"\n\n    location = data[\"location\"]\n    local_dealers = data[\"localDealers\"]\n\n    # Validate location fields\n    required_location_fields = [\"country\", \"countryCode\", \"region\", \"currency\", \"timeZone\"]\n    optional_location_fields = [\"city\"]\n\n    for field in required_location_fields:\n        assert field in location, f\"Location missing field '{field}'\"\n        assert isinstance(location[field], str), f\"Location field '{field}' should be a string\"\n\n    # Check city only if present\n    if \"city\" in location:\n        assert isinstance(location[\"city\"], str), \"Location field 'city' should be a string if present\"\n\n    # Validate localDealers is a list\n    assert isinstance(local_dealers, list), \"'localDealers' should be a list\"\n\n    # Validate each dealer's fields and types\n    expected_dealer_fields = {\n        \"name\": str,\n        \"url\": str,\n        \"country\": str,\n        \"region\": str,\n        \"searchUrlPattern\": str,\n        \"currency\": str,\n        \"priority\": int\n    }\n    for dealer in local_dealers:\n        assert isinstance(dealer, dict), \"Each dealer should be a dictionary\"\n        for field, field_type in expected_dealer_fields.items():\n            assert field in dealer, f\"Dealer missing field '{field}'\"\n            assert isinstance(dealer[field], field_type), f\"Dealer field '{field}' should be of type {field_type.__name__}\"\n\ntest_verify_get_user_location_and_local_dealers()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-07-20T17:41:59.018Z",
    "modified": "2025-07-20T17:43:31.057Z"
  },
  {
    "projectId": "2c4a704e-038b-40cd-a8c9-af06845f8369",
    "testId": "7b046481-8c91-4bec-bf13-060a8d314dd0",
    "userId": "341874e8-2011-70cc-0ea8-47f80d67dcd0",
    "title": "TC010-verify_admin_get_all_users_access_control",
    "description": "Test the admin users endpoint to verify that only admin users can access the list of all users, and that the response contains user details including id, email, admin status, creation date, and search count.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef register_user(email: str, password: str):\n    url = f\"{BASE_URL}/api/auth/register\"\n    payload = {\"email\": email, \"password\": password}\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    data = resp.json()\n    assert data.get(\"success\") is True\n    assert \"accessToken\" in data\n    assert \"user\" in data\n    return data[\"accessToken\"], data[\"user\"]\n\ndef login_user(email: str, password: str):\n    url = f\"{BASE_URL}/api/auth/login\"\n    payload = {\"email\": email, \"password\": password}\n    resp = requests.post(url, json=payload, timeout=TIMEOUT)\n    resp.raise_for_status()\n    data = resp.json()\n    assert data.get(\"success\") is True\n    assert \"accessToken\" in data\n    assert \"user\" in data\n    return data[\"accessToken\"], data[\"user\"]\n\ndef delete_user(token: str):\n    # No explicit delete user endpoint in PRD, so no deletion possible.\n    # This function is a placeholder if deletion is implemented later.\n    pass\n\ndef test_verify_admin_get_all_users_access_control():\n    # Create admin user\n    admin_email = f\"admin_{uuid.uuid4().hex}@example.com\"\n    admin_password = \"AdminPass123!\"\n    admin_token, admin_user = register_user(admin_email, admin_password)\n    # We need to ensure this user is admin. Since no endpoint to set admin, assume first user is admin or login as existing admin.\n    # If the registered user is not admin, try to login as a known admin user.\n    # For test, try login as admin user with known credentials fallback:\n    if not admin_user.get(\"isAdmin\", False):\n        # Try login as known admin user (replace with actual admin credentials if known)\n        # For this test, we assume admin user exists with email admin@example.com and password AdminPass123!\n        try:\n            admin_token, admin_user = login_user(\"admin@example.com\", \"AdminPass123!\")\n            assert admin_user.get(\"isAdmin\", False) is True\n        except Exception:\n            # If no known admin, skip admin tests as no admin user available\n            raise AssertionError(\"No admin user available for testing admin access control.\")\n\n    # Create normal user\n    user_email = f\"user_{uuid.uuid4().hex}@example.com\"\n    user_password = \"UserPass123!\"\n    user_token, user_user = register_user(user_email, user_password)\n    assert user_user.get(\"isAdmin\", False) is False\n\n    headers_admin = {\"Authorization\": f\"Bearer {admin_token}\"}\n    headers_user = {\"Authorization\": f\"Bearer {user_token}\"}\n\n    # Admin user should access /api/admin/users successfully\n    admin_users_url = f\"{BASE_URL}/api/admin/users\"\n    resp_admin = requests.get(admin_users_url, headers=headers_admin, timeout=TIMEOUT)\n    assert resp_admin.status_code == 200\n    data_admin = resp_admin.json()\n    assert \"users\" in data_admin\n    assert isinstance(data_admin[\"users\"], list)\n    for user in data_admin[\"users\"]:\n        assert isinstance(user.get(\"id\"), int)\n        assert isinstance(user.get(\"email\"), str)\n        assert isinstance(user.get(\"isAdmin\"), bool)\n        assert isinstance(user.get(\"createdAt\"), str)\n        assert isinstance(user.get(\"searchCount\"), int)\n\n    # Normal user should be forbidden or unauthorized to access /api/admin/users\n    resp_user = requests.get(admin_users_url, headers=headers_user, timeout=TIMEOUT)\n    assert resp_user.status_code in (401, 403)\n\n    # Unauthenticated request should be unauthorized\n    resp_unauth = requests.get(admin_users_url, timeout=TIMEOUT)\n    assert resp_unauth.status_code == 401\n\ntest_verify_admin_get_all_users_access_control()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 46, in test_verify_admin_get_all_users_access_control\n  File \"<string>\", line 22, in login_user\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 401 Client Error: Unauthorized for url: http://localhost:3000/api/auth/login\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 83, in <module>\n  File \"<string>\", line 50, in test_verify_admin_get_all_users_access_control\nAssertionError: No admin user available for testing admin access control.\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-07-20T17:41:59.024Z",
    "modified": "2025-07-20T17:43:23.498Z"
  }
]
