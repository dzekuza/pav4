[
  {
    "projectId": "3434d71d-1fa5-4398-bc78-23ec47e97ddf",
    "testId": "8d28103a-7275-45c7-baab-39e65ad2b6e0",
    "userId": "341874e8-2011-70cc-0ea8-47f80d67dcd0",
    "title": "TC001-verify_user_registration_functionality",
    "description": "Test the user registration endpoint to ensure new users can register successfully with valid email and password, and receive a JWT token and user details in response.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nREGISTER_ENDPOINT = \"/api/auth/register\"\nDELETE_USER_ENDPOINT = \"/api/admin/users\"  # No delete user endpoint specified in PRD, so no direct delete; will skip cleanup.\n\ndef verify_user_registration_functionality():\n    # Generate unique email to avoid conflicts\n    unique_email = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\n    password = \"TestPassword123!\"\n\n    url = BASE_URL + REGISTER_ENDPOINT\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    payload = {\n        \"email\": unique_email,\n        \"password\": password\n    }\n\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=30)\n        assert response.status_code == 201, f\"Expected status code 201, got {response.status_code}\"\n        data = response.json()\n        assert isinstance(data, dict), \"Response is not a JSON object\"\n        assert data.get(\"success\") is True, \"Success flag is not True\"\n        # Token or accessToken must be present and non-empty string\n        token = data.get(\"token\") or data.get(\"accessToken\")\n        assert token and isinstance(token, str) and len(token) > 0, \"JWT token missing or invalid\"\n        user = data.get(\"user\")\n        assert user and isinstance(user, dict), \"User object missing or invalid\"\n        assert isinstance(user.get(\"id\"), int), \"User id missing or not integer\"\n        assert user.get(\"email\") == unique_email, \"User email does not match registration email\"\n        assert isinstance(user.get(\"isAdmin\"), bool), \"User isAdmin flag missing or not boolean\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\nverify_user_registration_functionality()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-07-20T17:34:59.946Z",
    "modified": "2025-07-20T17:35:39.513Z"
  },
  {
    "projectId": "3434d71d-1fa5-4398-bc78-23ec47e97ddf",
    "testId": "a8445182-bc12-4f73-a282-eb7665c94c78",
    "userId": "341874e8-2011-70cc-0ea8-47f80d67dcd0",
    "title": "TC002-verify_user_login_functionality",
    "description": "Test the user login endpoint to verify that registered users can log in with correct credentials and receive a valid JWT token and user information.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef verify_user_login_functionality():\n    register_url = f\"{BASE_URL}/api/auth/register\"\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # Generate unique email for registration\n    unique_email = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\n    password = \"TestPassword123!\"\n\n    user_data = {\n        \"email\": unique_email,\n        \"password\": password\n    }\n\n    # Register user first to ensure user exists\n    try:\n        reg_resp = requests.post(register_url, json=user_data, headers=headers, timeout=TIMEOUT)\n        assert reg_resp.status_code == 201, f\"Registration failed with status {reg_resp.status_code}\"\n        reg_json = reg_resp.json()\n        assert reg_json.get(\"success\") is True, \"Registration response success flag is not True\"\n        assert \"user\" in reg_json, \"Registration response missing user info\"\n        assert reg_json[\"user\"][\"email\"] == unique_email, \"Registered user email mismatch\"\n    except Exception as e:\n        raise AssertionError(f\"User registration failed: {e}\")\n\n    # Now test login with the registered user credentials\n    try:\n        login_resp = requests.post(login_url, json=user_data, headers=headers, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n        login_json = login_resp.json()\n        assert login_json.get(\"success\") is True, \"Login response success flag is not True\"\n        # Validate presence of JWT tokens\n        assert \"token\" in login_json and isinstance(login_json[\"token\"], str) and login_json[\"token\"], \"Missing or invalid token in login response\"\n        assert \"accessToken\" in login_json and isinstance(login_json[\"accessToken\"], str) and login_json[\"accessToken\"], \"Missing or invalid accessToken in login response\"\n        # Validate user info\n        user_info = login_json.get(\"user\")\n        assert user_info is not None, \"Login response missing user info\"\n        assert user_info.get(\"email\") == unique_email, \"Logged in user email mismatch\"\n        assert isinstance(user_info.get(\"id\"), int), \"User id is missing or not an integer\"\n        assert isinstance(user_info.get(\"isAdmin\"), bool), \"User isAdmin flag missing or not boolean\"\n    except Exception as e:\n        raise AssertionError(f\"User login failed: {e}\")\n\nverify_user_login_functionality()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-07-20T17:34:59.952Z",
    "modified": "2025-07-20T17:35:48.131Z"
  },
  {
    "projectId": "3434d71d-1fa5-4398-bc78-23ec47e97ddf",
    "testId": "b4cd3af8-918a-40ae-ba41-09f2fe0fb011",
    "userId": "341874e8-2011-70cc-0ea8-47f80d67dcd0",
    "title": "TC003-verify_user_logout_functionality",
    "description": "Test the user logout endpoint to confirm that users can log out successfully and receive a confirmation response.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef verify_user_logout_functionality():\n    register_url = f\"{BASE_URL}/api/auth/register\"\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    logout_url = f\"{BASE_URL}/api/auth/logout\"\n\n    test_email = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\n    test_password = \"TestPass123!\"\n\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # Register a new user\n    register_payload = {\n        \"email\": test_email,\n        \"password\": test_password\n    }\n    try:\n        reg_resp = requests.post(register_url, json=register_payload, headers=headers, timeout=TIMEOUT)\n        assert reg_resp.status_code == 201, f\"Registration failed with status {reg_resp.status_code}\"\n        reg_data = reg_resp.json()\n        assert reg_data.get(\"success\") is True, \"Registration success flag not True\"\n        assert \"accessToken\" in reg_data, \"accessToken missing in registration response\"\n\n        # Login with the registered user\n        login_payload = {\n            \"email\": test_email,\n            \"password\": test_password\n        }\n        login_resp = requests.post(login_url, json=login_payload, headers=headers, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n        login_data = login_resp.json()\n        assert login_data.get(\"success\") is True, \"Login success flag not True\"\n        access_token = login_data.get(\"accessToken\")\n        assert access_token, \"accessToken missing in login response\"\n\n        auth_headers = {\n            \"Authorization\": f\"Bearer {access_token}\"\n        }\n\n        # Logout the user\n        logout_resp = requests.post(logout_url, headers=auth_headers, timeout=TIMEOUT)\n        assert logout_resp.status_code == 200, f\"Logout failed with status {logout_resp.status_code}\"\n        logout_data = logout_resp.json()\n        assert logout_data.get(\"success\") is True, \"Logout success flag not True\"\n\n    finally:\n        # Cleanup: No explicit delete user endpoint provided in PRD, so no deletion step.\n\n        pass\n\nverify_user_logout_functionality()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-07-20T17:34:59.957Z",
    "modified": "2025-07-20T17:35:42.354Z"
  },
  {
    "projectId": "3434d71d-1fa5-4398-bc78-23ec47e97ddf",
    "testId": "aa06da4c-0031-4fd6-be38-c1c8563f9631",
    "userId": "341874e8-2011-70cc-0ea8-47f80d67dcd0",
    "title": "TC004-verify_get_current_user_info",
    "description": "Test the endpoint to retrieve current authenticated user information, ensuring it returns correct user details including id, email, and admin status.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef verify_get_current_user_info():\n    register_url = f\"{BASE_URL}/api/auth/register\"\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    me_url = f\"{BASE_URL}/api/auth/me\"\n    logout_url = f\"{BASE_URL}/api/auth/logout\"\n\n    test_email = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\n    test_password = \"TestPass123!\"\n\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # Register a new user\n    register_payload = {\n        \"email\": test_email,\n        \"password\": test_password\n    }\n\n    try:\n        reg_resp = requests.post(register_url, json=register_payload, headers=headers, timeout=TIMEOUT)\n        assert reg_resp.status_code == 201, f\"Registration failed with status {reg_resp.status_code}\"\n        reg_data = reg_resp.json()\n        assert reg_data.get(\"success\") is True, \"Registration success flag not True\"\n        token = reg_data.get(\"token\") or reg_data.get(\"accessToken\")\n        assert token, \"No token received on registration\"\n        user = reg_data.get(\"user\")\n        assert user, \"No user data received on registration\"\n        assert isinstance(user.get(\"id\"), int), \"User id is not int\"\n        assert user.get(\"email\") == test_email, \"User email mismatch on registration\"\n        assert isinstance(user.get(\"isAdmin\"), bool), \"User isAdmin flag missing or not bool\"\n\n        # Login with the same user to get fresh token (optional but safer)\n        login_payload = {\n            \"email\": test_email,\n            \"password\": test_password\n        }\n        login_resp = requests.post(login_url, json=login_payload, headers=headers, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}\"\n        login_data = login_resp.json()\n        assert login_data.get(\"success\") is True, \"Login success flag not True\"\n        token = login_data.get(\"token\") or login_data.get(\"accessToken\")\n        assert token, \"No token received on login\"\n        user = login_data.get(\"user\")\n        assert user, \"No user data received on login\"\n        assert isinstance(user.get(\"id\"), int), \"User id is not int\"\n        assert user.get(\"email\") == test_email, \"User email mismatch on login\"\n        assert isinstance(user.get(\"isAdmin\"), bool), \"User isAdmin flag missing or not bool\"\n\n        auth_headers = {\n            \"Authorization\": f\"Bearer {token}\"\n        }\n\n        # Get current user info\n        me_resp = requests.get(me_url, headers=auth_headers, timeout=TIMEOUT)\n        assert me_resp.status_code == 200, f\"Get current user info failed with status {me_resp.status_code}\"\n        me_data = me_resp.json()\n        user_info = me_data.get(\"user\")\n        assert user_info, \"No user info in response\"\n        assert isinstance(user_info.get(\"id\"), int), \"User id is not int in current user info\"\n        assert user_info.get(\"email\") == test_email, \"User email mismatch in current user info\"\n        assert isinstance(user_info.get(\"isAdmin\"), bool), \"User isAdmin flag missing or not bool in current user info\"\n\n    finally:\n        # Logout the user to clean up session if possible\n        try:\n            if 'token' in locals():\n                logout_headers = {\n                    \"Authorization\": f\"Bearer {token}\"\n                }\n                requests.post(logout_url, headers=logout_headers, timeout=TIMEOUT)\n        except Exception:\n            pass\n\nverify_get_current_user_info()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-07-20T17:34:59.963Z",
    "modified": "2025-07-20T17:35:51.620Z"
  },
  {
    "projectId": "3434d71d-1fa5-4398-bc78-23ec47e97ddf",
    "testId": "7e5a0295-8e4c-4bbd-bae1-808dc2b8abe5",
    "userId": "341874e8-2011-70cc-0ea8-47f80d67dcd0",
    "title": "TC005-verify_add_search_to_history",
    "description": "Test the add search to history endpoint to ensure authenticated users can add search entries with url, title, and requestId, and receive a success response.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_verify_add_search_to_history():\n    # Register a new user for authentication\n    register_url = f\"{BASE_URL}/api/auth/register\"\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    search_history_url = f\"{BASE_URL}/api/search-history\"\n    logout_url = f\"{BASE_URL}/api/auth/logout\"\n\n    test_email = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\n    test_password = \"TestPass123!\"\n\n    headers = {\"Content-Type\": \"application/json\"}\n\n    # Register user\n    try:\n        reg_resp = requests.post(\n            register_url,\n            json={\"email\": test_email, \"password\": test_password},\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert reg_resp.status_code == 201, f\"Registration failed: {reg_resp.text}\"\n    except Exception as e:\n        raise AssertionError(f\"User registration request failed: {e}\")\n\n    # Login user to get token\n    try:\n        login_resp = requests.post(\n            login_url,\n            json={\"email\": test_email, \"password\": test_password},\n            headers=headers,\n            timeout=TIMEOUT,\n        )\n        assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n        login_data = login_resp.json()\n        assert login_data.get(\"success\") is True, \"Login success flag false\"\n        token = login_data.get(\"token\") or login_data.get(\"accessToken\")\n        assert token, \"No token received on login\"\n    except Exception as e:\n        raise AssertionError(f\"User login request failed: {e}\")\n\n    auth_headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": f\"Bearer {token}\"\n    }\n\n    # Prepare search entry data\n    search_entry = {\n        \"url\": \"https://example.com/product/123\",\n        \"title\": \"Example Product Title\",\n        \"requestId\": str(uuid.uuid4())\n    }\n\n    # Add search to history\n    try:\n        add_resp = requests.post(\n            search_history_url,\n            json=search_entry,\n            headers=auth_headers,\n            timeout=TIMEOUT,\n        )\n        assert add_resp.status_code == 201, f\"Add search to history failed: {add_resp.text}\"\n    except Exception as e:\n        raise AssertionError(f\"Add search to history request failed: {e}\")\n\n    # Logout user to clean up session\n    try:\n        logout_resp = requests.post(logout_url, headers=auth_headers, timeout=TIMEOUT)\n        assert logout_resp.status_code == 200, f\"Logout failed: {logout_resp.text}\"\n        logout_data = logout_resp.json()\n        assert logout_data.get(\"success\") is True, \"Logout success flag false\"\n    except Exception as e:\n        raise AssertionError(f\"Logout request failed: {e}\")\n\ntest_verify_add_search_to_history()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-07-20T17:34:59.969Z",
    "modified": "2025-07-20T17:35:46.012Z"
  },
  {
    "projectId": "3434d71d-1fa5-4398-bc78-23ec47e97ddf",
    "testId": "b5186d76-36c8-4e57-b2da-ee06cb1f6239",
    "userId": "341874e8-2011-70cc-0ea8-47f80d67dcd0",
    "title": "TC006-verify_get_user_search_history",
    "description": "Test the get user search history endpoint to verify that authenticated users can retrieve their search history with correct details and timestamps.",
    "code": "import requests\nimport uuid\nimport time\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef verify_get_user_search_history():\n    # Register a new user\n    register_url = f\"{BASE_URL}/api/auth/register\"\n    email = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\n    password = \"TestPass123!\"\n    register_payload = {\"email\": email, \"password\": password}\n    headers = {\"Content-Type\": \"application/json\"}\n\n    try:\n        reg_resp = requests.post(register_url, json=register_payload, headers=headers, timeout=TIMEOUT)\n        assert reg_resp.status_code == 201, f\"Registration failed: {reg_resp.text}\"\n        reg_data = reg_resp.json()\n        assert reg_data.get(\"success\") is True\n        token = reg_data.get(\"token\") or reg_data.get(\"accessToken\")\n        assert token, \"No token received on registration\"\n\n        auth_headers = {\"Authorization\": f\"Bearer {token}\", \"Content-Type\": \"application/json\"}\n\n        # Add a search entry to history\n        search_history_post_url = f\"{BASE_URL}/api/search-history\"\n        test_url = \"https://example.com/product/12345\"\n        test_title = \"Example Product Title\"\n        test_request_id = str(uuid.uuid4())\n        search_payload = {\n            \"url\": test_url,\n            \"title\": test_title,\n            \"requestId\": test_request_id\n        }\n        post_resp = requests.post(search_history_post_url, json=search_payload, headers=auth_headers, timeout=TIMEOUT)\n        assert post_resp.status_code == 201, f\"Failed to add search to history: {post_resp.text}\"\n\n        # Small delay to ensure timestamp difference if needed\n        time.sleep(1)\n\n        # Retrieve user search history\n        search_history_get_url = f\"{BASE_URL}/api/search-history\"\n        get_resp = requests.get(search_history_get_url, headers=auth_headers, timeout=TIMEOUT)\n        assert get_resp.status_code == 200, f\"Failed to get search history: {get_resp.text}\"\n        get_data = get_resp.json()\n        history = get_data.get(\"history\")\n        assert isinstance(history, list), \"History is not a list\"\n\n        # Find the added search entry in history\n        matched_entries = [entry for entry in history if entry.get(\"url\") == test_url and entry.get(\"title\") == test_title and entry.get(\"requestId\") == test_request_id]\n        assert matched_entries, \"Added search entry not found in history\"\n\n        # Validate timestamp format and presence\n        for entry in matched_entries:\n            timestamp = entry.get(\"timestamp\")\n            assert timestamp and isinstance(timestamp, str), \"Timestamp missing or not a string\"\n            # Optional: further validate timestamp format (ISO 8601)\n            # Example: 2025-07-19T12:34:56Z or with timezone offset\n            # Basic check for 'T' and ':' presence\n            assert \"T\" in timestamp and \":\" in timestamp, f\"Timestamp format invalid: {timestamp}\"\n\n    finally:\n        # Logout user to clean session (optional)\n        if 'token' in locals():\n            logout_url = f\"{BASE_URL}/api/auth/logout\"\n            try:\n                requests.post(logout_url, headers=auth_headers, timeout=TIMEOUT)\n            except Exception:\n                pass\n\nverify_get_user_search_history()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-07-20T17:34:59.974Z",
    "modified": "2025-07-20T17:35:56.116Z"
  },
  {
    "projectId": "3434d71d-1fa5-4398-bc78-23ec47e97ddf",
    "testId": "b4dc4950-ac73-450e-a420-8292ed60ff94",
    "userId": "341874e8-2011-70cc-0ea8-47f80d67dcd0",
    "title": "TC007-verify_product_scraping_functionality",
    "description": "Test the product scraping endpoint to ensure it scrapes product data correctly from a given URL, including product details and price comparisons, and returns a valid requestId.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef verify_product_scraping_functionality():\n    # Register a new user\n    register_url = f\"{BASE_URL}/api/auth/register\"\n    email = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\n    password = \"TestPass123!\"\n    register_payload = {\"email\": email, \"password\": password}\n    try:\n        reg_resp = requests.post(register_url, json=register_payload, timeout=TIMEOUT)\n        assert reg_resp.status_code == 201, f\"Registration failed: {reg_resp.text}\"\n        reg_data = reg_resp.json()\n        assert reg_data.get(\"success\") is True\n        token = reg_data.get(\"token\") or reg_data.get(\"accessToken\")\n        assert token, \"No token received on registration\"\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n\n        # Use a sample product URL for scraping\n        scrape_url = f\"{BASE_URL}/api/scrape\"\n        sample_product_url = \"https://example.com/product/sample-product-123\"\n        scrape_payload = {\n            \"url\": sample_product_url,\n            \"userLocation\": {\"country\": \"US\"}\n        }\n\n        scrape_resp = requests.post(scrape_url, json=scrape_payload, timeout=TIMEOUT)\n        assert scrape_resp.status_code == 200, f\"Scrape request failed: {scrape_resp.text}\"\n        scrape_data = scrape_resp.json()\n\n        # Validate product data presence and types\n        product = scrape_data.get(\"product\")\n        assert product is not None, \"No product data in response\"\n        assert isinstance(product.get(\"title\"), str) and product.get(\"title\"), \"Invalid or missing product title\"\n        assert isinstance(product.get(\"price\"), (int, float)), \"Invalid or missing product price\"\n        assert isinstance(product.get(\"currency\"), str) and product.get(\"currency\"), \"Invalid or missing product currency\"\n        assert isinstance(product.get(\"url\"), str) and product.get(\"url\"), \"Invalid or missing product url\"\n        assert isinstance(product.get(\"image\"), str), \"Invalid or missing product image\"\n        assert isinstance(product.get(\"store\"), str), \"Invalid or missing product store\"\n\n        # Validate comparisons array\n        comparisons = scrape_data.get(\"comparisons\")\n        assert isinstance(comparisons, list), \"Comparisons is not a list\"\n        for comp in comparisons:\n            assert isinstance(comp.get(\"title\"), str) and comp.get(\"title\"), \"Invalid comparison title\"\n            assert isinstance(comp.get(\"store\"), str), \"Invalid comparison store\"\n            assert isinstance(comp.get(\"price\"), (int, float)), \"Invalid comparison price\"\n            assert isinstance(comp.get(\"currency\"), str), \"Invalid comparison currency\"\n            assert isinstance(comp.get(\"url\"), str), \"Invalid comparison url\"\n            assert isinstance(comp.get(\"image\"), str), \"Invalid comparison image\"\n            assert isinstance(comp.get(\"condition\"), str), \"Invalid comparison condition\"\n            assert isinstance(comp.get(\"assessment\"), dict), \"Invalid comparison assessment\"\n\n        # Validate requestId presence and type\n        request_id = scrape_data.get(\"requestId\")\n        assert isinstance(request_id, str) and request_id, \"Invalid or missing requestId\"\n\n    finally:\n        # Logout user to clean session\n        try:\n            logout_url = f\"{BASE_URL}/api/auth/logout\"\n            requests.post(logout_url, headers={\"Authorization\": f\"Bearer {token}\"}, timeout=TIMEOUT)\n        except Exception:\n            pass\n\nverify_product_scraping_functionality()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 69, in <module>\n  File \"<string>\", line 36, in verify_product_scraping_functionality\nAssertionError: No product data in response\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-07-20T17:34:59.979Z",
    "modified": "2025-07-20T17:36:06.296Z"
  },
  {
    "projectId": "3434d71d-1fa5-4398-bc78-23ec47e97ddf",
    "testId": "aa4a4ed5-59c7-45c0-93d0-a0c21f9b671d",
    "userId": "341874e8-2011-70cc-0ea8-47f80d67dcd0",
    "title": "TC008-verify_n8n_webhook_scraping",
    "description": "Test the N8N webhook scraping endpoint to confirm it processes scraping requests correctly, returning main product details and suggestions with pricing and links.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef verify_n8n_webhook_scraping():\n    # Use a sample product URL for scraping\n    sample_url = \"https://example.com/product/sample-product\"\n    request_id = str(uuid.uuid4())\n    payload = {\n        \"url\": sample_url,\n        \"requestId\": request_id,\n        \"userLocation\": {\n            \"country\": \"US\"\n        }\n    }\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    try:\n        response = requests.post(\n            f\"{BASE_URL}/api/n8n-scrape\",\n            json=payload,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert response.status_code == 200, f\"Expected status 200, got {response.status_code}\"\n        data = response.json()\n        # Validate mainProduct presence and fields\n        assert \"mainProduct\" in data, \"Response missing 'mainProduct'\"\n        main_product = data[\"mainProduct\"]\n        for field in [\"title\", \"price\", \"image\", \"url\"]:\n            assert field in main_product, f\"'mainProduct' missing field '{field}'\"\n            assert isinstance(main_product[field], str), f\"'mainProduct.{field}' should be a string\"\n            assert main_product[field], f\"'mainProduct.{field}' should not be empty\"\n        # Validate suggestions presence and structure\n        assert \"suggestions\" in data, \"Response missing 'suggestions'\"\n        suggestions = data[\"suggestions\"]\n        assert isinstance(suggestions, list), \"'suggestions' should be a list\"\n        for suggestion in suggestions:\n            for field in [\"title\", \"standardPrice\", \"discountPrice\", \"site\", \"link\", \"image\"]:\n                assert field in suggestion, f\"Suggestion missing field '{field}'\"\n                assert isinstance(suggestion[field], str), f\"Suggestion field '{field}' should be a string\"\n                assert suggestion[field], f\"Suggestion field '{field}' should not be empty\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\nverify_n8n_webhook_scraping()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-07-20T17:34:59.985Z",
    "modified": "2025-07-20T17:36:01.753Z"
  },
  {
    "projectId": "3434d71d-1fa5-4398-bc78-23ec47e97ddf",
    "testId": "f8e145a7-95e7-40e7-9916-80f957e3ba4d",
    "userId": "341874e8-2011-70cc-0ea8-47f80d67dcd0",
    "title": "TC009-verify_get_user_location_and_local_dealers",
    "description": "Test the location endpoint to ensure it returns accurate user location data and a list of local dealers with relevant details such as name, url, country, and currency.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_verify_get_user_location_and_local_dealers():\n    url = f\"{BASE_URL}/api/location\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to /api/location failed: {e}\"\n\n    data = response.json()\n\n    # Validate top-level keys\n    assert \"location\" in data, \"Response missing 'location' key\"\n    assert \"localDealers\" in data, \"Response missing 'localDealers' key\"\n\n    location = data[\"location\"]\n    local_dealers = data[\"localDealers\"]\n\n    # Validate location fields\n    expected_location_fields = [\"country\", \"countryCode\", \"region\", \"currency\", \"timeZone\"]\n    for field in expected_location_fields:\n        assert field in location, f\"Location missing field '{field}'\"\n        assert isinstance(location[field], str), f\"Location field '{field}' should be a string\"\n\n    # 'city' may be missing, so check if present and type\n    if \"city\" in location:\n        assert isinstance(location[\"city\"], str), \"Location field 'city' should be a string\"\n\n    # Validate localDealers is a list\n    assert isinstance(local_dealers, list), \"'localDealers' should be a list\"\n\n    # Validate each dealer's fields and types\n    expected_dealer_fields = {\n        \"name\": str,\n        \"url\": str,\n        \"country\": str,\n        \"region\": str,\n        \"searchUrlPattern\": str,\n        \"currency\": str,\n        \"priority\": int\n    }\n    for dealer in local_dealers:\n        assert isinstance(dealer, dict), \"Each dealer should be a dictionary\"\n        for field, field_type in expected_dealer_fields.items():\n            assert field in dealer, f\"Dealer missing field '{field}'\"\n            assert isinstance(dealer[field], field_type), f\"Dealer field '{field}' should be of type {field_type.__name__}\"\n\ntest_verify_get_user_location_and_local_dealers()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-07-20T17:34:59.991Z",
    "modified": "2025-07-20T17:36:16.903Z"
  },
  {
    "projectId": "3434d71d-1fa5-4398-bc78-23ec47e97ddf",
    "testId": "b6bd1572-049f-4c52-a8c0-183cc601969a",
    "userId": "341874e8-2011-70cc-0ea8-47f80d67dcd0",
    "title": "TC010-verify_admin_get_all_users_access_control",
    "description": "Test the admin users endpoint to verify that only admin users can access the list of all users, and that the response contains user details including id, email, admin status, creation date, and search count.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef verify_admin_get_all_users_access_control():\n    # Helper function to register a user\n    def register_user(email, password):\n        url = f\"{BASE_URL}/api/auth/register\"\n        payload = {\"email\": email, \"password\": password}\n        resp = requests.post(url, json=payload, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()\n\n    # Helper function to login a user\n    def login_user(email, password):\n        url = f\"{BASE_URL}/api/auth/login\"\n        payload = {\"email\": email, \"password\": password}\n        resp = requests.post(url, json=payload, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()\n\n    # Helper function to delete user if API supported (not in PRD, so skip)\n    # Instead, just rely on unique emails for test isolation\n\n    # Create admin user\n    admin_email = f\"admin_{uuid.uuid4().hex}@example.com\"\n    admin_password = \"AdminPass123!\"\n    admin_token = None\n\n    # Create non-admin user\n    user_email = f\"user_{uuid.uuid4().hex}@example.com\"\n    user_password = \"UserPass123!\"\n    user_token = None\n\n    try:\n        # Register admin user\n        admin_reg = register_user(admin_email, admin_password)\n        assert admin_reg.get(\"success\") is True\n        # If the registered user is not admin by default, we need to login and check\n        # But PRD does not specify admin creation, assume first user is admin or admin flag is false\n        # So login admin user to get token and isAdmin flag\n        admin_login = login_user(admin_email, admin_password)\n        assert admin_login.get(\"success\") is True\n        admin_token = admin_login.get(\"accessToken\") or admin_login.get(\"token\")\n        assert admin_token is not None\n        assert isinstance(admin_login.get(\"user\"), dict)\n        # We need admin user, so check isAdmin flag\n        if not admin_login[\"user\"].get(\"isAdmin\", False):\n            # If not admin, we cannot test admin access properly, so skip test with assertion error\n            raise AssertionError(\"Registered admin user does not have admin privileges.\")\n\n        # Register non-admin user\n        user_reg = register_user(user_email, user_password)\n        assert user_reg.get(\"success\") is True\n        user_login = login_user(user_email, user_password)\n        assert user_login.get(\"success\") is True\n        user_token = user_login.get(\"accessToken\") or user_login.get(\"token\")\n        assert user_token is not None\n        assert isinstance(user_login.get(\"user\"), dict)\n        assert user_login[\"user\"].get(\"isAdmin\", False) is False\n\n        # Test admin access to /api/admin/users\n        admin_headers = {\"Authorization\": f\"Bearer {admin_token}\"}\n        admin_resp = requests.get(f\"{BASE_URL}/api/admin/users\", headers=admin_headers, timeout=TIMEOUT)\n        assert admin_resp.status_code == 200\n        admin_data = admin_resp.json()\n        assert \"users\" in admin_data\n        assert isinstance(admin_data[\"users\"], list)\n        # Validate each user object has required fields\n        for user in admin_data[\"users\"]:\n            assert isinstance(user.get(\"id\"), int)\n            assert isinstance(user.get(\"email\"), str)\n            assert isinstance(user.get(\"isAdmin\"), bool)\n            assert isinstance(user.get(\"createdAt\"), str)\n            # searchCount can be zero or more\n            assert isinstance(user.get(\"searchCount\"), int)\n\n        # Test non-admin access to /api/admin/users - should be forbidden or unauthorized\n        user_headers = {\"Authorization\": f\"Bearer {user_token}\"}\n        user_resp = requests.get(f\"{BASE_URL}/api/admin/users\", headers=user_headers, timeout=TIMEOUT)\n        # Expect 403 Forbidden or 401 Unauthorized\n        assert user_resp.status_code in (401, 403)\n\n        # Test unauthenticated access to /api/admin/users - should be unauthorized\n        no_auth_resp = requests.get(f\"{BASE_URL}/api/admin/users\", timeout=TIMEOUT)\n        assert no_auth_resp.status_code in (401, 403)\n\n    except requests.RequestException as e:\n        raise AssertionError(f\"HTTP request failed: {e}\")\n\nverify_admin_get_all_users_access_control()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 93, in <module>\n  File \"<string>\", line 52, in verify_admin_get_all_users_access_control\nAssertionError: Registered admin user does not have admin privileges.\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-07-20T17:34:59.996Z",
    "modified": "2025-07-20T17:36:06.755Z"
  }
]
